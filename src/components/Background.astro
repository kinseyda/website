---
// Fancy background component using paper.js
// Wraps a canvas element and initializes paper.js on it
---

<canvas id="paper-canvas" class="w-full h-full blur-xs"></canvas>

<script>
  import paper from "paper";

  // Initialize paper.js on the canvas
  const canvas = document.getElementById("paper-canvas") as HTMLCanvasElement;
  paper.setup(canvas);

  const view = paper.view;

  function mapRange(
    value: number,
    inMin: number,
    inMax: number,
    outMin: number,
    outMax: number
  ): number {
    // Maps a value from one range to another linearly
    return ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;
  }

  function sumOfSines(
    freqs: number[],
    time: number,
    speed: number
  ): (x: number) => number {
    return (x) => {
      // Calculate the sum of sine waves for the given frequencies, time, and speed
      let sum = 0;
      for (let i = 0; i < freqs.length; i++) {
        sum += Math.sin((x + time * speed) * freqs[i]);
      }
      return sum / freqs.length; // Normalize by the number of frequencies
    };
  }

  /**
   *
   * @param func Function to evaluate at each x
   * @param fullWidth Full width of the canvas in pixels
   * @param fullHeight Full height of the canvas in pixels
   * @param waveHeight Height of the wave to draw in pixels
   * @param padding Padding around the wave in pixels
   * @param color Color of the wave line
   * @param samples Number of samples to take across the width of the canvas
   * @param domain Domain we sample from over the full width of the canvas
   * @param smoothing
   */
  function fullWidthMathFunc(
    func: (x: number) => number,
    fullWidth: number,
    fullHeight: number,
    waveHeight: number,
    padding: number,
    color: string = "white",
    samples: number = 100,
    domain: [number, number] = [0, fullWidth],
    smoothing: boolean = true
  ): paper.Path {
    const path = new paper.Path();
    path.strokeColor = new paper.Color(color);
    path.strokeWidth = 5;

    const startX = domain[0];
    const endX = domain[1];
    const step = (endX - startX) / samples;

    // Samples array to include the x values at the very start and end of the domain
    const samplesArray = Array.from(
      { length: samples + 1 },
      (_, i) => startX + i * step
    );

    for (const x of samplesArray) {
      const y = func(x);
      // Add points to the path, offsetting y by half the height to center it vertically
      // This centers the wave vertically in the canvas
      const mappedX = mapRange(
        x,
        domain[0],
        domain[1],
        -1 * padding,
        fullWidth + padding
      );
      path.add(new paper.Point(mappedX, waveHeight * y + fullHeight / 2));
    }
    if (smoothing) {
      // Smooth the path if requested
      path.smooth();
    }

    return path;
  }

  // Retrieve the daisyui theme colors
  function getDaisyUIColor(varName: string): string {
    // Use the daisyui CSS variable name like `--color-primary`

    // Try to get from body, fallback to :root
    const style = getComputedStyle(document.body);
    return (
      style.getPropertyValue(varName) ||
      getComputedStyle(document.documentElement).getPropertyValue(varName)
    );
  }

  function redraw(
    event: paper.Event & { count: number; time: number; delta: number }
  ) {
    // Clear previous paths
    paper.project.activeLayer.removeChildren();

    // Low sample size but with smoothing makes for a neat, unpredictable wavy effect.

    // Add new paths based on the current time
    paper.project.activeLayer.addChild(
      fullWidthMathFunc(
        (x) => sumOfSines([54, 64, 81], event.time, 0.025)(x), // Slowing it way down
        // 54, 64, 81, are the pythagorean frequencies of a minor chord
        view.size.width,
        view.size.height,
        100, // Height of the wave
        50, // Padding around the wave
        getDaisyUIColor("--color-primary"),
        20,
        [0, 1],
        true
      )
    );
  }

  view.onFrame = (
    event: paper.Event & { count: number; time: number; delta: number }
  ) => {
    redraw(event);
  };
  view.onResize = () => {
    // Redraw on resize
    const event = new paper.Event() as paper.Event & {
      count: 0;
      time: 0;
      delta: 0;
    };
    redraw(event);
  };
  window.addEventListener("resize", () => {
    // Redraw on window resize
    const event = new paper.Event() as paper.Event & {
      count: 0;
      time: 0;
      delta: 0;
    };
    redraw(event);
  });
</script>

<style>
  canvas[resize] {
    width: 100%;
    height: 100%;
  }
</style>
